#!/usr/bin/env node
import { writeFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import path from 'node:path';

const PUBLICATION = 'szuhan';
const ARCHIVE_URL = `https://${PUBLICATION}.substack.com/api/v1/archive?sort=new&offset=0&limit=20`;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const targetFile = path.resolve(__dirname, '../src/lib/data/substack.ts');

const normaliseArticle = (raw, index) => {
	const title = raw?.title ?? raw?.headline ?? raw?.name ?? null;
	const slug = raw?.slug ?? raw?.id ?? `post-${index}`;
	const url = raw?.canonical_url ?? raw?.url ?? `https://${PUBLICATION}.substack.com/p/${slug}`;
	const summary =
		raw?.subtitle ??
		raw?.description ??
		raw?.search_description ??
		raw?.body_text ??
		raw?.body?.preview_text ??
		null;
	const publishedRaw =
		raw?.post_date ??
		raw?.published_at ??
		raw?.publish_date ??
		raw?.created_at ??
		raw?.first_published_at ??
		raw?.post_created_at ??
		raw?.release_date ??
		raw?.date ??
		raw?.updated_at ??
		raw?.time ??
		new Date().toISOString();

	if (!title || !url) {
		return null;
	}

	const publishedAt = new Date(publishedRaw);
	const safePublishedAt = Number.isNaN(publishedAt.valueOf())
		? new Date().toISOString()
		: publishedAt.toISOString();

	const tagSet = new Set();

	if (Array.isArray(raw?.tag_names)) {
		raw.tag_names.filter(Boolean).forEach((tag) => tagSet.add(String(tag)));
	}

	if (Array.isArray(raw?.tags)) {
		raw.tags.forEach((tag) => {
			if (!tag) return;
			if (typeof tag === 'string') {
				tagSet.add(tag);
				return;
			}
			if (tag?.name) {
				tagSet.add(String(tag.name));
			}
		});
	}

	if (Array.isArray(raw?.sections)) {
		raw.sections.forEach((section) => {
			if (!section) return;
			if (typeof section === 'string') {
				tagSet.add(section);
				return;
			}
			if (section?.name) {
				tagSet.add(String(section.name));
			}
		});
	}

	const readingTime =
		typeof raw?.reading_time === 'number'
			? raw.reading_time
			: typeof raw?.reading_time_minutes === 'number'
				? raw.reading_time_minutes
				: typeof raw?.estimated_reading_time === 'number'
					? raw.estimated_reading_time
					: null;

	return {
		id: String(raw?.id ?? raw?.post_id ?? slug),
		title,
		slug: String(slug),
		summary: summary ? String(summary) : '',
		url,
		publishedAt: safePublishedAt,
		coverImage:
			raw?.cover_image_url ??
			raw?.cover_image ??
			raw?.photo_url ??
			raw?.image_url ??
			raw?.social_image ??
			raw?.hero_photo_url ??
			raw?.thumbnail_url ??
			null,
		tags: Array.from(tagSet),
		readingTimeMinutes: readingTime
	};
};

const buildFileContents = (articles, meta) => {
	const banner = `// Auto-generated by scripts/update-substack.mjs\n// Run \`pnpm sync:blogs\` to refresh the cache.\n`;
	const importLine = `import type { SubstackArticle, SubstackDatasetMeta } from '$lib/types/blog';\n\n`;
	const articlesExport = `export const substackArticles: SubstackArticle[] = ${JSON.stringify(articles, null, 2)};\n\n`;
	const metaExport = `export const substackMeta: SubstackDatasetMeta = ${JSON.stringify(meta, null, 2)};\n`;
	return `${banner}${importLine}${articlesExport}${metaExport}`;
};

const main = async () => {
	const response = await fetch(ARCHIVE_URL, {
		headers: {
			accept: 'application/json'
		}
	});

	if (!response.ok) {
		throw new Error(`Failed to retrieve Substack archive (${response.status} ${response.statusText})`);
	}

	const payload = await response.json();
	const items = Array.isArray(payload)
		? payload
		: Array.isArray(payload?.items)
			? payload.items
			: Array.isArray(payload?.posts)
				? payload.posts
				: Array.isArray(payload?.data)
					? payload.data
					: [];

	if (!Array.isArray(items) || items.length === 0) {
		throw new Error('Substack archive returned no posts.');
	}

	const articles = items
		.map(normaliseArticle)
		.filter(Boolean)
		.sort((a, b) => new Date(b.publishedAt).valueOf() - new Date(a.publishedAt).valueOf());

	const meta = {
		lastUpdated: new Date().toISOString(),
		source: ARCHIVE_URL
	};

	const fileContents = buildFileContents(articles, meta);
	await writeFile(targetFile, fileContents, 'utf8');
	console.log(`Updated ${articles.length} Substack articles â†’ src/lib/data/substack.ts`);
};

main().catch((error) => {
	console.error(error instanceof Error ? error.message : error);
	process.exitCode = 1;
});
